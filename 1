diff --git a/discovery/src/dns.rs b/discovery/src/dns.rs
index bd76327..65ecdfe 100644
--- a/discovery/src/dns.rs
+++ b/discovery/src/dns.rs
@@ -64,15 +64,15 @@ fn system_resolver() -> Resolver {
 mod test {
     use tokio::runtime::Runtime;
 
-    use crate::DnsResolver;
+    // use crate::DnsResolver;
 
     #[test]
     fn test_lookup_dns() {
         let rt = Runtime::new().unwrap();
         rt.block_on(async {
-            let dns = DnsResolver::with_sysy_conf();
+            // let dns = DnsResolver::with_sysy_conf();
             let host = "baidu.com";
-            let ips = dns.lookup_ips(host).await;
+            let ips = super::lookup_ips(host);
             println!("async parse dns/{} ips:", host);
             for ip in ips {
                 println!(" {:?}", ip);
diff --git a/ds/src/mem/guarded.rs b/ds/src/mem/guarded.rs
index 1cad839..9b70322 100644
--- a/ds/src/mem/guarded.rs
+++ b/ds/src/mem/guarded.rs
@@ -120,6 +120,17 @@ impl MemGuard {
         let guard = 0 as *const _;
         Self { mem, guard, cap }
     }
+
+    pub fn from_ringslice(data: RingSlice) -> Self {
+        let guard = 0 as *const _;
+        let cap = data.capacity();
+        Self {
+            mem: data,
+            guard,
+            cap,
+        }
+    }
+
     #[inline(always)]
     pub fn data(&self) -> &RingSlice {
         &self.mem
diff --git a/ds/src/mem/ring_slice.rs b/ds/src/mem/ring_slice.rs
index 0e7db51..f21efa4 100644
--- a/ds/src/mem/ring_slice.rs
+++ b/ds/src/mem/ring_slice.rs
@@ -23,6 +23,12 @@ impl RingSlice {
         };
         me
     }
+
+    #[inline(always)]
+    pub fn capacity(&self) -> usize {
+        self.cap
+    }
+
     #[inline(always)]
     pub fn sub_slice(&self, offset: usize, len: usize) -> RingSlice {
         debug_assert!(offset + len <= self.len());
@@ -142,6 +148,13 @@ impl RingSlice {
     pub fn index_lf_cr(&self, offset: usize) -> Option<usize> {
         self.find_sub(offset, &[b'\r', b'\n'])
     }
+
+    #[inline]
+    pub fn to_vec(&self) -> Vec<u8> {
+        let mut v = Vec::with_capacity(self.len());
+        self.copy_to_vec(&mut v);
+        v
+    }
 }
 
 unsafe impl Send for RingSlice {}
diff --git a/endpoint/src/redisservice/topo.rs b/endpoint/src/redisservice/topo.rs
index 5264b15..025e991 100644
--- a/endpoint/src/redisservice/topo.rs
+++ b/endpoint/src/redisservice/topo.rs
@@ -60,7 +60,11 @@ where
     #[inline(always)]
     fn send(&self, mut req: Self::Item) {
         debug_assert_ne!(self.shards.len(), 0);
-        let shard_idx = req.hash() as usize % self.shards.len();
+        // TODO：原分布算法计算有问题，先临时实现，验证流程 fishermen
+        const RANGE_LEN: u64 = 256;
+        let interval = RANGE_LEN / self.shards.len() as u64;
+        let shard_idx = (req.hash() / interval) as usize;
+
         let shard = unsafe { self.shards.get_unchecked(shard_idx) };
         let mut idx = 0;
         // 如果有从，并且是读请求。
diff --git a/protocol/src/error.rs b/protocol/src/error.rs
index 8792020..09623f0 100644
--- a/protocol/src/error.rs
+++ b/protocol/src/error.rs
@@ -7,6 +7,7 @@ pub enum Error {
     NotInit,
     Closed,
     QueueFull,
+    ProtocolIncomplete,
     RequestProtocolNotValid,
     ResponseProtocolNotValid,
     ProtocolNotSupported,
@@ -36,3 +37,8 @@ impl Display for Error {
         write!(f, "error: {:?}", self)
     }
 }
+
+pub enum ProtocolType {
+    Request,
+    Response,
+}
diff --git a/protocol/src/parser.rs b/protocol/src/parser.rs
index 74c98b3..5e0d7e8 100644
--- a/protocol/src/parser.rs
+++ b/protocol/src/parser.rs
@@ -73,6 +73,14 @@ pub trait Builder {
 pub struct Flag {
     v: u64,
 }
+
+const REQ_BIT_PADDING_RSP: u8 = 32;
+const REQ_BIT_KEY_COUNT: u8 = 16;
+// const REQ_BIT_FIRST_KEY: u8 = 8;
+const REQ_BIT_VAL_FIRST_KEY: u64 = 1 << 8;
+
+const RSP_BIT_META_LEN: u8 = 16;
+const RSP_BIT_TOKEN_LEN: u8 = 8;
 impl Flag {
     // first = true 满足所有条件1. 当前请求是multiget；2. 拆分了多个子请求；3. 是`第一`个子请求；
     // last  = true 满足所有条件1. 当前请求是multiget；2. 拆分了多个子请求；3. 是`最后`一个子请求；
@@ -81,6 +89,73 @@ impl Flag {
         let v = ((op_code as u64) << 8) | (op as u64);
         Self { v }
     }
+
+    // **********************  TODO: redis相关，需要按协议分拆 start **********************
+    // TODO: 后续flag需要根据协议进行分别构建 speedup fishermen
+    #[inline(always)]
+    pub fn from_mkey_op(first_key: bool, key_count: u16, padding_rsp: u8, op: Operation) -> Self {
+        let mut v = 0u64;
+        if key_count > 0 {
+            v |= (key_count as u64) << REQ_BIT_KEY_COUNT;
+
+            // 只有多个key时，first key才有意义
+            if first_key {
+                v |= REQ_BIT_VAL_FIRST_KEY;
+            }
+        }
+
+        if padding_rsp > 0 {
+            v |= (padding_rsp as u64) << REQ_BIT_PADDING_RSP;
+        }
+
+        // operation 需要小雨
+        v |= op as u64;
+
+        Self { v }
+    }
+
+    // meta len 正常不会超过20，256绰绰有余
+    pub fn from_metalen_tokencount(metalen: u8, tokencount: u8) -> Self {
+        let mut v = 0u64;
+        if metalen > 0 {
+            v |= (metalen as u64) >> RSP_BIT_META_LEN;
+        }
+        if tokencount > 0 {
+            v |= (tokencount as u64) >> RSP_BIT_TOKEN_LEN;
+        }
+        Self { v }
+    }
+
+    pub fn padding_rsp(&self) -> u8 {
+        const MASK: u64 = 1 << REQ_BIT_PADDING_RSP - 1;
+        let p = (self.v >> REQ_BIT_PADDING_RSP) & MASK;
+        p as u8
+    }
+
+    pub fn key_count(&self) -> u16 {
+        const MASK: u64 = 1u64 << REQ_BIT_KEY_COUNT - 1;
+        let count = self.v >> REQ_BIT_KEY_COUNT & MASK;
+        return count as u16;
+    }
+
+    pub fn is_first_key(&self) -> bool {
+        (self.v & REQ_BIT_VAL_FIRST_KEY) == REQ_BIT_VAL_FIRST_KEY
+    }
+
+    pub fn meta_len(&self) -> u8 {
+        const MASK: u64 = 1 << RSP_BIT_META_LEN - 1;
+        let len = self.v >> RSP_BIT_META_LEN & MASK;
+        len as u8
+    }
+
+    pub fn token_len(&self) -> u8 {
+        const MASK: u64 = 1u64 << RSP_BIT_TOKEN_LEN - 1;
+        let len = self.v >> RSP_BIT_TOKEN_LEN & MASK;
+        len as u8
+    }
+
+    // **********************  TODO: redis相关，需要按协议分拆 end！speedup **********************
+
     #[inline(always)]
     pub fn new() -> Self {
         Self { v: 0 }
diff --git a/protocol/src/redis/mod.rs b/protocol/src/redis/mod.rs
index 3fb2292..f1f6b8a 100644
--- a/protocol/src/redis/mod.rs
+++ b/protocol/src/redis/mod.rs
@@ -1,22 +1,341 @@
-#[derive(Clone, Default)]
-pub struct Redis;
+mod command;
+mod token;
+
+use std::str::from_utf8;
+use token::Token;
+
 use crate::{
-    Command, Commander, Error, Flag, HashedCommand, Protocol, RequestProcessor, Result, Stream,
+    error::ProtocolType, redis::command::PADDING_RSP_TABLE, Command, Commander, Error, Flag,
+    HashedCommand, Protocol, RequestProcessor, Result, Stream,
 };
+use ds::{MemGuard, RingSlice};
 use sharding::hash::Hash;
-impl Protocol for Redis {
+
+// redis 协议最多支持10w个token
+const MAX_TOKEN_COUNT: usize = 100000;
+// 最大消息支持1M
+const MAX_MSG_LEN: usize = 1000000;
+
+#[derive(Clone, Default)]
+pub struct Redis;
+
+impl Redis {
+    // 一条redis消息，包含多个token，每个token有2部分，meta部分记录长度信息，数据部分是有效信息。
+    // eg：let s = b"*5\r\n$4\r\nMSET\r\n$2\r\nk1\r\n$2\r\nv1\r\n$2\r\nk2\r\n";
+    // 上面的redis协议，有5个token，分别是mset k1 v1 k2 v2，每个token前面的$len即为meta
+    // TODO: 返回的error，如果是ProtocolIncomplete，说明是协议没有读取完毕，后续需要继续读
     #[inline(always)]
+    fn parse_request_inner<S: Stream, H: Hash, P: RequestProcessor>(
+        &self,
+        stream: &mut S,
+        alg: &H,
+        process: &mut P,
+    ) -> Result<()> {
+        debug_assert!(stream.len() > 0);
+        if stream.len() < 4 {
+            return Ok(());
+        }
+
+        // 解析multibulk count：*5\r\n
+        let buf = stream.slice();
+        let mut pos = 0;
+        if buf.at(pos) as char != '*' {
+            return Err(Error::RequestProtocolNotValid);
+        }
+        pos += 1;
+        let len = buf.len();
+        let (token_counto, int_len) = parse_len(
+            buf.sub_slice(pos, len - pos),
+            "multibulk",
+            ProtocolType::Request,
+        )?;
+        let token_count = match token_counto {
+            None => 0,
+            Some(c) => c,
+        };
+        pos += int_len;
+        if token_count > MAX_TOKEN_COUNT {
+            log::warn!("found too long redis req with tokens/{}", token_count);
+            return Err(Error::RequestProtocolNotValid);
+        }
+
+        debug_assert!(token_count > 0);
+        // 解析bulk tokens：$3\r\n123\r\n
+        let mut tokens = Vec::with_capacity(token_count);
+        for i in 0..token_count {
+            if pos >= len {
+                return Err(Error::ProtocolIncomplete);
+            }
+            if buf.at(pos) as char != '$' {
+                return Err(Error::RequestProtocolNotValid);
+            }
+            let meta_pos = pos;
+            pos += 1;
+            let (token_leno, meta_len) =
+                parse_len(buf.sub_slice(pos, len - pos), "bulk", ProtocolType::Request)?;
+            let token_len = match token_leno {
+                Some(l) => l,
+                None => return Err(Error::RequestProtocolNotValid),
+            };
+            if token_len >= MAX_MSG_LEN {
+                return Err(Error::RequestProtocolNotValid);
+            }
+            pos += meta_len;
+            let token = Token::from(meta_pos, meta_len, pos, token_len);
+            tokens.push(token);
+            pos += token_len + 2;
+            if pos > len || (pos == len && i != token_count - 1) {
+                return Err(Error::ProtocolIncomplete);
+            }
+        }
+
+        // cmd的name在第一个str，解析并进行cmd校验
+        // TODO: 还有映射的指令，后面再结合eredis整理fishermen
+        let cmd_token = tokens.get(0).unwrap();
+        let name_data = cmd_token.bare_data(&buf).to_vec();
+        let cmdname = to_str(&name_data, ProtocolType::Request)?;
+
+        let prop = command::command_properties(cmdname);
+        let last_key_idx = prop.last_key_index(tokens.len());
+        let share_tokens_count = tokens.len() - (last_key_idx - prop.first_key_index() + 1);
+        prop.validate(tokens.len());
+
+        // 如果没有key，或者key的个数为1，直接执行
+        if prop.first_key_index() == 0
+            || ((last_key_idx + 1 - prop.first_key_index()) / prop.key_step() == 1)
+        {
+            let mut key_count = 0;
+            let hash;
+            if prop.first_key_index() == 0 {
+                log::info!(
+                    "++++++++ cmdnme:{:?}, cmd: {:?}",
+                    cmdname,
+                    to_str(&buf.to_vec(), ProtocolType::Request)?
+                );
+                debug_assert!(prop.operation().is_meta());
+                use std::sync::atomic::{AtomicU64, Ordering};
+                static RND: AtomicU64 = AtomicU64::new(0);
+                hash = RND.fetch_add(1, Ordering::Relaxed);
+            } else {
+                let ktoken = tokens.get(prop.first_key_index()).unwrap();
+                hash = alg.hash(&ktoken.bare_data(&buf));
+                key_count = 1;
+            }
+
+            let reqdata = buf.sub_slice(0, pos);
+            let guard = MemGuard::from_ringslice(reqdata);
+            // TODO: flag 还需要针对指令进行进一步设计
+            let flag = Flag::from_mkey_op(
+                false,
+                key_count,
+                prop.padding_rsp(),
+                prop.operation().clone(),
+            );
+            let cmd = HashedCommand::new(guard, hash, flag);
+
+            // 处理完毕的字节需要take
+            stream.take(pos);
+
+            // process cmd
+            process.process(cmd, true);
+            return Ok(());
+        }
+
+        // 多个key，需要进行分拆
+
+        // 共享第一个token/cmd及第一个key之前的数据，及最后一个key之后的数据
+        let first_key_token = tokens.get(prop.first_key_index()).unwrap();
+        let last_key_token = tokens.get(last_key_idx).unwrap();
+        let prefix = buf
+            .sub_slice(cmd_token.meta_pos, first_key_token.meta_pos)
+            .to_vec();
+        let suffix = buf
+            .sub_slice(last_key_token.end_pos(), len - last_key_token.end_pos())
+            .to_vec();
+        let first_key_idx = prop.first_key_index();
+
+        // 轮询构建协议，并处理
+        if last_key_idx > 20000 {
+            log::warn!(
+                "too many keys/{} in redis request",
+                last_key_idx - first_key_idx + 1
+            );
+            return Err(Error::ProtocolNotSupported);
+        }
+
+        let mut kidx = prop.first_key_index();
+        let key_count: u16 = match first_key_idx {
+            0 => 0,
+            _ => (last_key_idx - first_key_idx + 1) as u16,
+        };
+
+        while kidx <= last_key_idx {
+            let mut rdata: Vec<u8> = Vec::with_capacity(len);
+            // 需要确定出了key之外，其他所有的token都要复制
+            rdata.extend(format!("*{}\r\n", share_tokens_count + prop.key_step()).as_bytes());
+            // prefix.copy_to_vec(&rdata);
+            rdata.extend(prefix.clone());
+            let mut j = 0;
+            while j < prop.key_step() {
+                let token = tokens.get(kidx + j).unwrap();
+                rdata.extend(token.bulk_data(&buf).to_vec());
+                j += 1;
+            }
+            rdata.extend(suffix.clone());
+
+            let key_token = tokens.get(kidx).unwrap();
+            let hash = alg.hash(&key_token.bare_data(&buf));
+
+            let guard = MemGuard::from_vec(rdata);
+            // flag 目前包含3个属性：key-count，is-first-key，operation
+            let flag: Flag = match kidx == first_key_idx {
+                true => Flag::from_mkey_op(
+                    true,
+                    key_count,
+                    prop.padding_rsp(),
+                    prop.operation().clone(),
+                ),
+                false => Flag::from_mkey_op(
+                    false,
+                    key_count,
+                    prop.padding_rsp(),
+                    prop.operation().clone(),
+                ),
+            };
+            let cmd = HashedCommand::new(guard, hash, flag);
+
+            // 处理完毕的字节需要take
+            stream.take(pos);
+
+            // process cmd
+            process.process(cmd, kidx == last_key_idx);
+
+            // key处理完毕，跳到下一个key
+            kidx += prop.key_step();
+        }
+
+        Ok(())
+    }
+}
+
+impl Protocol for Redis {
     fn parse_request<S: Stream, H: Hash, P: RequestProcessor>(
         &self,
         stream: &mut S,
         alg: &H,
         process: &mut P,
     ) -> Result<()> {
-        todo!();
+        match self.parse_request_inner(stream, alg, process) {
+            Ok(_) => Ok(()),
+            Err(e) => match e {
+                Error::ProtocolIncomplete => Ok(()),
+                _ => Err(e),
+            },
+        }
     }
+
+    // 为每一个req解析一个response
     #[inline(always)]
     fn parse_response<S: Stream>(&self, data: &mut S) -> Result<Option<Command>> {
-        todo!();
+        let response = data.slice();
+        // 响应目前只记录meta前缀长度
+        let mut pos = 0;
+        match response.at(0) as char {
+            '*' => {
+                pos += 1;
+                let len = response.len();
+                // multibulks count
+                let (token_counto, meta_lenlen) = parse_len(
+                    response.sub_slice(pos, len - pos),
+                    "bulk",
+                    ProtocolType::Response,
+                )?;
+
+                let token_count = match token_counto {
+                    Some(c) => c,
+                    None => 0,
+                };
+                pos += meta_lenlen;
+
+                // 记录meta 长度
+                debug_assert!(pos < 256);
+                let flag = Flag::from_metalen_tokencount(pos as u8, token_count as u8);
+                if token_count > 1 {
+                    log::warn!(
+                        "found special resp with tokens/{}: {:?}",
+                        token_count,
+                        response
+                    );
+                }
+
+                // 解析并验证bulk tokens：$3\r\n123\r\n
+                for i in 0..token_count {
+                    if pos >= len {
+                        return Err(Error::ProtocolIncomplete);
+                    }
+                    if response.at(pos) as char != '$' {
+                        return Err(Error::ResponseProtocolNotValid);
+                    }
+
+                    pos += 1;
+                    let (token_leno, meta_len) = parse_len(
+                        response.sub_slice(pos, len - pos),
+                        "bulk",
+                        ProtocolType::Response,
+                    )?;
+
+                    let token_len = match token_leno {
+                        Some(l) => l,
+                        None => 0,
+                    };
+                    if token_len >= MAX_MSG_LEN {
+                        log::warn!("careful too long token: {}", token_len);
+                    }
+                    pos += meta_len + token_len + token::REDIS_SPLIT_LEN;
+                    if pos > len || (pos == len && i != token_count - 1) {
+                        return Err(Error::ProtocolIncomplete);
+                    }
+                }
+
+                // 到了这里，response已经解析完毕
+                return Ok(Some(Command::new(flag, data.take(pos))));
+            }
+            '$' => {
+                // one bulk
+                let (leno, meta_len) = parse_len(
+                    response.sub_slice(0, response.len()),
+                    "rsp-bulk",
+                    ProtocolType::Response,
+                )?;
+                let len = match leno {
+                    Some(l) => l,
+                    None => 0,
+                };
+                if len > MAX_MSG_LEN {
+                    log::warn!("found too long respons/{}", len);
+                }
+                pos += meta_len + len;
+                if len > 0 {
+                    // 只有bare len大于0，才会有bare data + \r\n
+                    pos += token::REDIS_SPLIT_LEN;
+                }
+                let flag = Flag::from_metalen_tokencount(0, 1u8);
+                return Ok(Some(Command::new(flag, data.take(pos))));
+            }
+            _ => {
+                // others
+                for i in 1..(response.len() - 1) {
+                    if response.at(i) as char == '\r' && response.at(i + 1) as char == '\n' {
+                        // i 为pos，+1 为len，再+1到下一个字符\n
+                        // let rdata = response.sub_slice(0, i + 1 + 1);
+                        let len = i + 1 + 1;
+                        let flag = Flag::from_metalen_tokencount(0, 1u8);
+                        return Ok(Some(Command::new(flag, data.take(len))));
+                    }
+                }
+                return Err(Error::ProtocolIncomplete);
+            }
+        }
     }
     #[inline(always)]
     fn write_response<C: Commander, W: crate::ResponseWriter>(
@@ -24,14 +343,113 @@ impl Protocol for Redis {
         ctx: &mut C,
         w: &mut W,
     ) -> Result<()> {
-        todo!();
+        // 首先确认request是否multi-key
+        let key_count = ctx.request().key_count();
+        let is_mkey_first = match key_count > 1 {
+            true => ctx.request().is_first_key(),
+            false => false,
+        };
+
+        // 如果是多个key的req，需要过滤掉每个resp的meta
+        let resp = ctx.response();
+        let mut oft = 0usize;
+        if key_count > 1 {
+            // 对于多个key，需要去掉所有resp的meta前缀
+            oft = resp.meta_len() as usize;
+        }
+        let len = resp.len() - oft;
+
+        // 首先发送完整的meta
+        // TODO: 1 如果有分片全部不可用，需要构建默认异常响应;
+        // TODO: 2 特殊多key的响应 key_count 可能等于token数量？需要确认（理论上不应该存在） fishermen
+        if is_mkey_first {
+            let meta = format!("*{}\r\n", key_count);
+            w.write(meta.as_bytes())?;
+        }
+
+        // 发送剩余rsp
+        while oft < len {
+            let data = resp.read(oft);
+            w.write(data)?;
+            oft += data.len();
+        }
+        Ok(())
+
+        // 多个key，第一个response增加multi-bulk-len前缀，后面所有的response去掉bulk-len前缀
     }
     #[inline(always)]
     fn write_no_response<W: crate::ResponseWriter>(
         &self,
-        _req: &HashedCommand,
-        _w: &mut W,
+        req: &HashedCommand,
+        w: &mut W,
     ) -> Result<()> {
-        todo!();
+        let rsp_idx = req.padding_rsp() as usize;
+        debug_assert!(rsp_idx < PADDING_RSP_TABLE.len());
+        let rsp = *PADDING_RSP_TABLE.get(rsp_idx).unwrap();
+        w.write(rsp.as_bytes())?;
+        Ok(())
+    }
+}
+
+pub fn parse_len(
+    data: RingSlice,
+    name: &str,
+    ptype: ProtocolType,
+) -> Result<(Option<usize>, usize)> {
+    if data.len() <= 2 {
+        return Err(Error::ProtocolIncomplete);
+    }
+    let len = data.len();
+    let mut idx = 0;
+    let mut count = 0;
+    let mut count_op = None;
+    let invalid_err = match ptype {
+        ProtocolType::Request => Error::RequestProtocolNotValid,
+        ProtocolType::Response => Error::ResponseProtocolNotValid,
+    };
+    while data.at(idx) as char != '\r' {
+        let c = data.at(idx) as char;
+        if c == '-' {
+            // 处理 $-1 这种情况
+            idx += 1;
+            while data.at(idx) as char != '\r' {
+                idx += 1;
+                if idx == len {
+                    return Err(Error::ProtocolIncomplete);
+                }
+            }
+            count_op = None;
+            break;
+        } else if c < '0' || c > '9' {
+            log::warn!("found malformed len for {}", name);
+            return Err(invalid_err);
+        }
+        count *= 10;
+        count += c as usize - '0' as usize;
+        idx += 1;
+        if idx == len {
+            return Err(Error::ProtocolIncomplete);
+        }
+        count_op = Some(count);
+    }
+
+    idx += 1;
+    if data.at(idx) as char != '\n' {
+        return Err(invalid_err);
+    }
+    // 长度包括flag和换行符，如"*123\r\n"是6，“$123\r\n”也是6
+    Ok((count_op, idx + 1))
+}
+
+//
+pub fn to_str(data: &Vec<u8>, ptype: ProtocolType) -> Result<&str> {
+    let invalid_err = match ptype {
+        ProtocolType::Request => Error::RequestProtocolNotValid,
+        ProtocolType::Response => Error::ResponseProtocolNotValid,
+    };
+
+    match from_utf8(data.as_slice()) {
+        Ok(s) => Ok(s),
+        Err(_e) => Err(invalid_err),
     }
 }
diff --git a/sharding/src/distribution/consistent.rs b/sharding/src/distribution/consistent.rs
index 4b60457..e829519 100644
--- a/sharding/src/distribution/consistent.rs
+++ b/sharding/src/distribution/consistent.rs
@@ -4,7 +4,7 @@ use crypto::md5::Md5;
 use std::collections::BTreeMap;
 use std::ops::Bound::Included;
 
-#[derive(Clone)]
+#[derive(Clone, Debug, Default)]
 pub struct Consistent {
     buckets: BTreeMap<i64, usize>,
 }
diff --git a/sharding/src/distribution/mod.rs b/sharding/src/distribution/mod.rs
index 7caabb4..ad93572 100644
--- a/sharding/src/distribution/mod.rs
+++ b/sharding/src/distribution/mod.rs
@@ -1,20 +1,25 @@
 mod consistent;
-use consistent::Consistent;
-
 mod modula;
+mod range;
+
+use consistent::Consistent;
 use modula::Modula;
+use range::Range;
 
-#[derive(Clone)]
+#[derive(Clone, Debug)]
 pub enum Distribute {
     Consistent(Consistent),
     Modula(Modula),
+    Range(Range),
 }
 
 impl Distribute {
     pub fn from(distribution: &str, names: &Vec<String>) -> Self {
-        match distribution {
-            "modula" | "Modula" | "MODULA" => Self::Modula(Modula::from(names.len())),
-            "ketama" | "Ketama" | "KETAMA" => Self::Consistent(Consistent::from(&names)),
+        let dist = distribution.to_ascii_lowercase();
+        match dist.as_str() {
+            "modula" => Self::Modula(Modula::from(names.len())),
+            "ketama" => Self::Consistent(Consistent::from(names)),
+            "range" => Self::Range(Range::from(names.len())),
             _ => {
                 log::warn!("'{}' is not valid , use modula instead", distribution);
                 Self::Modula(Modula::from(names.len()))
@@ -26,6 +31,7 @@ impl Distribute {
         match self {
             Self::Consistent(d) => d.index(hash),
             Self::Modula(d) => d.index(hash),
+            Self::Range(r) => r.index(hash),
         }
     }
 }
diff --git a/sharding/src/distribution/modula.rs b/sharding/src/distribution/modula.rs
index a2bfaa7..473398b 100644
--- a/sharding/src/distribution/modula.rs
+++ b/sharding/src/distribution/modula.rs
@@ -1,4 +1,4 @@
-#[derive(Clone)]
+#[derive(Clone, Debug)]
 pub enum Modula {
     Pow2(Pow2),
     Other(Other),
@@ -22,7 +22,7 @@ impl Modula {
     }
 }
 
-#[derive(Clone)]
+#[derive(Clone, Debug, Default)]
 pub struct Pow2 {
     mask: usize,
 }
@@ -38,7 +38,7 @@ impl Pow2 {
     }
 }
 
-#[derive(Clone)]
+#[derive(Clone, Debug, Default)]
 pub struct Other {
     len: usize,
 }
diff --git a/sharding/src/distribution/range.rs b/sharding/src/distribution/range.rs
index 86bd8d5..f29a3fc 100644
--- a/sharding/src/distribution/range.rs
+++ b/sharding/src/distribution/range.rs
@@ -1,4 +1,5 @@
 // 按区间进行分布，比如[0,16)分区，每段间隔是4，则分为4个区间：[0,4),[4,8),[8,12),[12,16)
+#[derive(Clone, Debug, Default)]
 pub struct Range {
     interval: u64,
 }
diff --git a/sharding/src/hash/bkdr.rs b/sharding/src/hash/bkdr.rs
index fac9080..2a31a54 100644
--- a/sharding/src/hash/bkdr.rs
+++ b/sharding/src/hash/bkdr.rs
@@ -1,4 +1,4 @@
-#[derive(Clone, Default)]
+#[derive(Clone, Default, Debug)]
 pub struct Bkdr;
 
 //TODO 参考java版本调整，手动测试各种长度key，hash一致，需要线上继续验证 fishermen
diff --git a/sharding/src/hash/crc32.rs b/sharding/src/hash/crc32.rs
index e060827..6d9ff10 100644
--- a/sharding/src/hash/crc32.rs
+++ b/sharding/src/hash/crc32.rs
@@ -34,55 +34,164 @@ const CRC32TAB: [i64; 256] = [
 ];
 
 const CRC_SEED: i64 = 0xFFFFFFFF;
-#[derive(Default, Clone)]
+
+// 用于兼容jdk版本crc32算法
+#[derive(Default, Clone, Debug)]
 pub struct Crc32 {}
 
-//TODO 参考java 内部实现版本 以及 api-commons中crc32 hash算法调整，手动测试各种长度key，hash一致，需要线上继续验证 fishermen
+// 用于mc crc32 short hash变种
+#[derive(Default, Clone, Debug)]
+pub struct Crc32Short {}
+
+// 用于redis的区间crc32变种
+#[derive(Default, Clone, Debug)]
+pub struct Crc32Range {
+    start: usize,
+    only_digit: bool, // 是否只对digit部分进行hash
+}
+
+// 在start为0且only_num为false时，兼容crc32的原始实现，与java.util.zip.CRC32的多种长度数据的计算结果相同（jdk的CRC32核心算法是native不可见）
+pub(crate) fn crc32_raw<K: super::HashKey>(key: &K, start: usize, only_digit: bool) -> i64 {
+    let mut crc: i64 = CRC_SEED;
+    let mut idx = 0;
+    for i in 0..key.len() {
+        if idx < start {
+            idx += 1;
+            continue;
+        }
+
+        let c = key.at(i);
+        if only_digit && !c.is_ascii_digit() {
+            break;
+        }
+        crc = ((crc >> 8) & 0x00FFFFFF) ^ CRC32TAB[((crc ^ (c as i64)) & 0xff) as usize];
+        idx += 1;
+    }
+    crc ^= CRC_SEED;
+    crc &= CRC_SEED;
+    if crc < 0 {
+        log::warn!(
+            "negative hash key:{:?},[{}/{}]",
+            key.vec_data(),
+            start,
+            only_digit
+        );
+    }
+    crc
+}
+
 impl super::Hash for Crc32 {
     fn hash<K: super::HashKey>(&self, key: &K) -> u64 {
-        let mut crc: i64 = CRC_SEED;
-        for i in 0..key.len() {
-            let c = key.at(i);
-            crc = ((crc >> 8) & 0x00FFFFFF) ^ CRC32TAB[((crc ^ (c as i64)) & 0xff) as usize];
+        let mut rs = crc32_raw(key, 0, false);
+        if rs < 0 {
+            rs *= -1;
         }
-        crc ^= CRC_SEED;
-        crc &= CRC_SEED;
+        rs as u64
+    }
+}
 
+// 兼容api-commons中mc crc32 hash算法调整，手动测试各种长度key，hash一致；
+// 理论上应该与线上一致，注意跟进线上不一致场景 fishermen
+impl super::Hash for Crc32Short {
+    fn hash<K: super::HashKey>(&self, key: &K) -> u64 {
+        let crc = crc32_raw(key, 0, false);
         let mut rs = (crc >> 16) & 0x7fff;
         if rs < 0 {
+            log::warn!("found negative crc32 hash for key:{:?}", key.vec_data());
             rs = rs.wrapping_mul(-1);
         }
-        return rs as u64;
+
+        rs as u64
     }
 }
 
-impl Crc32 {
-    // crc-32 标准规范实现，与mc实现存在差异
-    fn _hash_spec(&mut self, key: &[u8]) -> u64 {
-        let mut crc: i64 = !0;
-        for c in key {
-            crc = CRC32TAB[((crc ^ *c as i64) & 0xFF) as usize] ^ (crc >> 8);
+// 兼容api-commons中redis的crc32 hash算法，同时支持各种场景的hash计算，线上待验证 fishermen
+impl Crc32Range {
+    pub fn from(alg: &str) -> Self {
+        if alg.len() == super::CRC32_BASE_LEN {
+            // format: crc32-range
+            Self {
+                start: 0,
+                only_digit: false,
+            }
+        } else {
+            // format: crc32-range-uid-xxx，如果xxx不是合法数字，则直接使用全部的key来hash
+            debug_assert!(alg.len() > (super::CRC32_RANGE_ID_PREFIX_LEN));
+            let start = &alg[super::CRC32_RANGE_ID_PREFIX_LEN..];
+            if let Ok(s) = start.parse::<usize>() {
+                return Self {
+                    start: s,
+                    only_digit: true,
+                };
+            } else {
+                return Self {
+                    start: 0,
+                    only_digit: false,
+                };
+            }
         }
-        return (crc ^ !0) as u64;
     }
 }
+const DEFAULT_RANGE_SPLIT: i64 = 256;
+impl super::Hash for Crc32Range {
+    fn hash<K: super::HashKey>(&self, key: &K) -> u64 {
+        let crc = crc32_raw(key, self.start, self.only_digit);
+        let mut hash = crc
+            .wrapping_div(DEFAULT_RANGE_SPLIT)
+            .wrapping_rem(DEFAULT_RANGE_SPLIT);
+        if hash < 0 {
+            log::warn!("found negative crc range hash for key:{:?}", key.vec_data());
+            hash = hash.wrapping_abs();
+        }
+        hash as u64
+    }
+}
+
+// impl Crc32 {
+//     // crc-32 标准规范实现，与mc/jdk实现存在差异
+//     fn _hash_spec(&mut self, key: &[u8]) -> u64 {
+//         let mut crc: i64 = !0;
+//         for c in key {
+//             crc = CRC32TAB[((crc ^ *c as i64) & 0xFF) as usize] ^ (crc >> 8);
+//         }
+//         return (crc ^ !0) as u64;
+//     }
+// }
 
 #[cfg(test)]
 mod crc_test {
-    use crate::{bkdr::Bkdr, Hash};
 
-    use super::Crc32;
+    use crate::{bkdr::Bkdr, distribution::Distribute, Hash};
+
+    use super::{Crc32Range, Crc32Short};
 
     #[test]
-    fn crc32_test() {
+    fn crc32_mc_test() {
         // let key = "123";
         let key = "12345678901234567890123456789.fri";
-        let mut crc = Crc32 {};
-        let _hash = crc.hash(key.as_bytes());
+        let crc = Crc32Short {};
+        let _hash = crc.hash(&key.as_bytes());
         println!("crc32 - key: {}, hash: {}", key, _hash);
 
-        let mut bkdr = Bkdr {};
-        let bkdr_hash = bkdr.hash(key.as_bytes());
+        let bkdr = Bkdr {};
+        let bkdr_hash = bkdr.hash(&key.as_bytes());
         println!("bkdr - key: {}, hash: {}", key, bkdr_hash);
     }
+
+    #[test]
+    fn crc32_redis_test() {
+        println!("===========crc32-redis test start...");
+        let key = "4711424389024351.repost";
+        let crc32 = Crc32Range::from("crc32-range-id-0");
+        let hash = crc32.hash(&key.as_bytes());
+
+        let mut shards = Vec::with_capacity(8);
+        for _i in 0..8 {
+            shards.push("1".to_string());
+        }
+        let dist = Distribute::from("range", &shards);
+        let idx = dist.index(hash);
+
+        println!("crc32-redis - key:{}, hash:{}, dist:{}", key, hash, idx);
+    }
 }
diff --git a/sharding/src/hash/mod.rs b/sharding/src/hash/mod.rs
index 4c527ee..ba88179 100644
--- a/sharding/src/hash/mod.rs
+++ b/sharding/src/hash/mod.rs
@@ -2,7 +2,7 @@ pub mod bkdr;
 pub mod crc32;
 
 pub use bkdr::Bkdr;
-pub use crc32::Crc32;
+pub use crc32::*;
 
 use enum_dispatch::enum_dispatch;
 #[enum_dispatch]
@@ -11,36 +11,53 @@ pub trait Hash {
 }
 
 #[enum_dispatch(Hash)]
-#[derive(Clone)]
+#[derive(Debug, Clone)]
 pub enum Hasher {
     Bkdr(Bkdr),
-    Crc32(Crc32),
+    Crc32Short(Crc32Short), // mc short crc32
+    Crc32Range(Crc32Range), // redis crc32 range hash
 }
 
+// crc32-short和crc32-range长度相同，所以此处选一个
+const CRC32_BASE_LEN: usize = "crc32-range".len();
+const CRC32_RANGE_ID_PREFIX_LEN: usize = "crc32-range-id-".len();
+
 impl Hasher {
     pub fn from(alg: &str) -> Self {
-        match alg {
-            "bkdr" | "BKDR" => Self::Bkdr(Default::default()),
-            "crc32" | "CRC32" => Self::Crc32(Default::default()),
-            _ => Self::Crc32(Default::default()),
+        let alg_lower = alg.to_ascii_lowercase();
+        let mut alg_match = alg_lower.as_str();
+        if alg_match.len() > CRC32_BASE_LEN {
+            alg_match = &alg_match[0..CRC32_BASE_LEN];
+        }
+
+        match alg_match {
+            "bkdr" => Self::Bkdr(Default::default()),
+            "crc32-short" => Self::Crc32Short(Default::default()),
+            "crc32-range" => Self::Crc32Range(Crc32Range::from(alg_lower.as_str())),
+            _ => {
+                // 默认采用mc的crc32-s hash
+                log::warn!("found unknow hash:{}, use crc32-short instead", alg);
+                Self::Crc32Short(Default::default())
+            } // _ => Self::Crc32(Default::default()),
         }
     }
     #[inline(always)]
-    pub fn crc32() -> Self {
-        Self::Crc32(Default::default())
+    pub fn crc32_short() -> Self {
+        Self::Crc32Short(Default::default())
     }
 }
 
 impl Default for Hasher {
     #[inline]
     fn default() -> Self {
-        Self::crc32()
+        Self::crc32_short()
     }
 }
 
 pub trait HashKey {
     fn len(&self) -> usize;
     fn at(&self, idx: usize) -> u8;
+    fn vec_data(&self) -> Vec<u8>;
 }
 
 impl HashKey for &[u8] {
@@ -52,6 +69,12 @@ impl HashKey for &[u8] {
     fn at(&self, idx: usize) -> u8 {
         unsafe { *self.as_ptr().offset(idx as isize) }
     }
+    #[inline(always)]
+    fn vec_data(&self) -> Vec<u8> {
+        let mut data = Vec::with_capacity(self.len());
+        data.extend(*self);
+        data
+    }
 }
 
 impl HashKey for ds::RingSlice {
@@ -63,4 +86,8 @@ impl HashKey for ds::RingSlice {
     fn at(&self, idx: usize) -> u8 {
         (*self).at(idx)
     }
+    #[inline(always)]
+    fn vec_data(&self) -> Vec<u8> {
+        self.to_vec()
+    }
 }
diff --git a/sharding/src/lib.rs b/sharding/src/lib.rs
index 41e1b02..de4430c 100644
--- a/sharding/src/lib.rs
+++ b/sharding/src/lib.rs
@@ -1,3 +1,4 @@
+#[derive(Debug, Clone)]
 pub struct Sharding {
     hash: Hasher,
     distribution: Distribute,

use std::fmt::Debug;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};

use futures::ready;
use metrics::{Metric, Path, BASE_PATH};

use super::timeout::TimeoutEvent;

pub trait ReEnter {
    // 发送的请求数量
    #[inline(always)]
    fn num_tx(&self) -> usize {
        0
    }
    // 接收到的请求数量
    #[inline(always)]
    fn num_rx(&self) -> usize {
        0
    }
}
//  统计
//  1. 每次poll的执行耗时
//  2. 重入耗时间隔
pub struct Timeout<F> {
    last: Instant,
    inner: F,
    te: TimeoutEvent,
    te_reg: bool,
    m_reenter: Metric,
}
impl<F: Future + Unpin + ReEnter + Debug> Timeout<F> {
    #[inline]
    pub fn from(f: F, timeout: Duration) -> Self {
        let te = super::timeout::subscribe_timeout_event(timeout);
        let m_reenter = Path::new(vec![BASE_PATH]).rtt("reenter10ms");
        metrics::incr_task();
        Self {
            inner: f,
            last: Instant::now(),
            m_reenter,
            te,
            te_reg: false,
        }
    }
}

use protocol::Result;
impl<F: Future<Output = Result<()>> + ReEnter + Debug + Unpin> Future for Timeout<F> {
    type Output = F::Output;
    #[inline(always)]
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        if !self.te_reg {
            self.te.start(cx.waker().clone());
            self.te_reg = true;
        }
        let (tx, rx) = (self.inner.num_tx(), self.inner.num_rx());
        if tx > rx {
            let elapsed = self.last.elapsed();
            if elapsed >= Duration::from_millis(10) {
                self.m_reenter += elapsed;
            }
            if self.te.is_timeout() {
                return Poll::Ready(Err(protocol::Error::Timeout(self.te.elapsed())));
            }
        }
        let ret = Pin::new(&mut self.inner).poll(cx);
        let (tx_post, rx_post) = (self.inner.num_tx(), self.inner.num_rx());
        if tx_post == rx_post {
            // 没有需要等待的请求。
            self.te.pause();
        } else {
            debug_assert!(tx_post > tx_post);
            // 需要记录reenter的耗时。
            self.last = Instant::now();
            // 有收到新的response
            if rx_post > rx {
                self.te.refresh();
            }
            // else {} // 等待超时
        }
        let output = ready!(ret);
        self.te.stop();
        Poll::Ready(output)
    }
}
impl<F> Drop for Timeout<F> {
    #[inline]
    fn drop(&mut self) {
        metrics::decr_task();
    }
}
